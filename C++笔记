C++对c的增强：
（1）全局变量检测int a；int a = 10；（C语言可以通过，但C++不可以）
（2）函数检测，参数类型个数等
（3）类型转换检测，必须强制类型转换
（4）struct增强，里面可以放函数
（5）bool数据，（c里没有）
（6）三目运算符增强，c中返回值，C++返回变量
（7）const增强，c中可以通过指针修改值，伪常量，但C++相当于一个Key：value符号表，没分配内存，自然也没办法修改，可以真正替换初始初始化数组int a[value]
引用：就是起别名，一个指针常量，还有指针引用，常量引用（参数里面加const）
重载：
（1）重载条件：必须在同一作用域，不同参数类型，数量，默认参数不能产生二义性
（2）返回值不可以作重载条件
内联函数：
（1）类内部成员，默认加inline
（2）类似于宏，但是是优化版，宏定义缺陷不知类型，比如a++，它不会灵活用
引用重载：
必须有合法的内存空间
const也可作为重载的条件 int tmp = 10； const int &a = tmp；
封装：
C语言封装：行为和属性分开，类型检测不强；
C++封装，严格类型转换检测，让属性和行为绑在一起，作为一个整体来表示生活整体事物。另外还有控制权限，public，protecteed，private；
尽量用私有方法设置成员属性，自己提供公共的对外接口进行set和get方法来访问变量。
引用传递花销会少一点，值传递会额外增加一个中间值传递。
利用全局函数（要两个不同的参数）和成员函数（另外一个参数跟自己本身内部变量对比，只需另外一个参数）进行判断，参数有所不一样。
构造函数:(放在public里)
构造函数（对象初始化），与类名相同，没有返回值，不用写void，可以发生重载（可以带参数），编译器会自动调用，但只有一次。
析构函数没有参数
分类有两种方式：1.参数{无参构造函数（默认），有参构造函数}；2.类型{普通构造函数，拷贝构造函数(Person(const Person&p）),放另外一个对象)}
Person(10)是匿名对象，执行完当前行就会释放这个对象
拷贝构造函数Person(const Person& p），Person p2 (p1)；或者Person p2 = Person(p1);不能用拷贝构造函数初始化匿名对象
默认拷贝构造函数是值传递，只可以传递属性值
？？？什么适合调用拷贝构造函数（不是很理解），用已经创建好的对象创建新对象
浅拷贝：是系统默认提供的拷贝函数，只是很肤浅的值拷贝属性的地址和名称，一旦放在堆上的变量释放掉，后面也想跟着删掉，但是没得删，报错（解决问题需要自己创建拷贝构造函数）。而深拷贝则会另外开辟一块内存用来用来存放
对象初始化列表，构造函数后面加：属性值（参数）
当类对象作为类的成员，构造顺序先构造类对象，然后构造自己，析构则与之相反。
explicit关键字是防止构造函数中的隐式类型转换
所有new出来的对象都会返回该类型的指针，malloc则返回void*，并且还要强转，也不会调用构造函数。new是一个运算符，malloc则是系统提供的函数。
new运算符，new出来数组，如何释放？delete [] 数组名；中括号非常重要，不然只会释放一个。同时new出来数组，肯定会调用默认构造函数，如果有参了，记得也要有默认无参构造函数。
staic静态成员变量，类内声明，类外实现定义。编译的时候分配内存，可以实现多个对象共享同一数据（通过对象访问属性；通过类名：：访问属性），可以权限控制
静态成员函数，不可以访问 普通成员变量，因为共享数据，无法识别将哪个对象的修改，但是可以访问静态成员变量，因为不需要区分
单例模式：一个类只有一个全局对象
常函数 void func（）const，常函数修饰this指针 const Type（Person） * const this；常函数不能修改this指针指向的值；
常对象 不可以调用普通的成员函数	常对象 可以调用常函数


new ：
2022-2023：
# 关于系统调用和库函数
系统调用通常用于底层文件访问（low-level file access），例如在驱动程序中对设备文件的直接访问。

**系统调用是操作系统相关的，因此一般没有跨操作系统的可移植性 **

系统调用发生在内核空间，因此如果在用户空间的一般应用程序中使用系统调用来进行文件操作，会有用户空间到内核空间切换的开销。
使用库函数也有系统调用的开销，为什么不直接使用系统调用呢？这是因为，读写文件通常是大量的数据（这种大量是相对于底层驱动的系统调用所实现的数据操作单位而言），这时，使用库函数就可以大大减少系统调用的次数。这一结果又缘于缓冲区技术。在用户空间和内核空间，对文件操作都使用了缓冲区，例如用fwrite写文件，都是先将内容写到用户空间缓冲区，当用户空间缓冲区满或者写操作结束时，才将用户缓冲区的内容写到内核缓冲区，同样的道理，当内核缓冲区满或写结束时才将内核缓冲区内容写到文件对应的硬件媒介。
****

* 进程中每个打开的文件都用一个编号来标识，称为文件描述符，文件描述符1表示标准输出，对应于C标准I/O库的stdout
* 用Unbuffered I/O函数每次读写都要进内核，调一个系统调用比调一个用户空间的函数要慢很多，所以在用户空间开辟I/O缓冲区还是必要的，用C标准I/O库函数就比较方便，省去了自己管理I/O缓冲区的麻烦。

* 用C标准I/O库函数要时刻注意I/O缓冲区和实际文件有可能不一致，在必要时需调用fflush(3)。

* 我们知道UNIX的传统是Everything is a file，I/O函数不仅用于读写常规文件，也用于读写设备，比如终端或网络设备。在读写设备时通常是不希望有缓冲的，例如向代表网络设备的文件写数据就是希望数据通过网络设备发送出去，而不希望只写到缓冲区里就算完事儿了，当网络设备接收到数据时应用程序也希望第一时间被通知到，所以网络编程通常直接调用Unbuffered I/O函数。

* 注意open函数与C标准I/O库的fopen函数有些细微的区别：

    以可写的方式fopen一个文件时，如果文件不存在会自动创建，而open一个文件时必须明确指定O_CREAT才会创建文件，否则文件不存在就出错返回。

    以w或w+方式fopen一个文件时，如果文件已存在就截断为0字节，而open一个文件时必须明确指定O_TRUNC才会截断文件，否则直接在原来的数据上改写。
    
******
* 装搜狗输入法：(装依赖)
```
sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb
sudo apt install -f
sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb
```
*****
* 构造方法用来初始化类的对象，与父类的其它成员不同，它不能被子类继承（子类可以继承父类所有的成员变量和成员方法，但不继承父类的构造方法）。因此，在创建子类对象时，为了初始化从父类继承来的数据成员，系统需要调用其父类的构造方法。子类构造函数必须要调用父类的构造函数（无论显式还是隐式），本质原因在于继承的性质决定了必须先有父再有子！

* 信号：特定情况触发的被发射的时间，如点击信号
* 槽：对信号响应的函数，当信号发射时，关联的槽函数被自动执行，信号和槽关联通过QObject::connect()函数实现的
* QDialog dialog 这样是定义了一个对象，QDialog  * dialog 是定义了一个指向QDialog类对象的指针变量
* 回调函数的应用非常的广泛。通常，我们需要一个统一得接口来实现不同内容的时候，用回调函数来实现就非常合适；可以实现对象之间的通信

```
QOject::connect(sender,SIGNAL(signal()),recevier,SOLT(slot()));
```
* 继承：
```
class  QWDlgManual : public QDialog
```


dpkg锁解决案例：
```
sudo rm /var/lib/dpkg/lock-frontend
    （sudo apt-get  install libgstreamer0.10-dev）
    sudo rm /var/cache/apt/archives/lock
    sudo rm /var/lib/dpkg/lock
```
*****


 # 日常任务
1.  关于QT学习的布局管理器
* 水平（ctrl+H），垂直（ctrl+L），分裂器（运行后可以自己拖拉伸缩），伙伴（&+英文快捷键，快速定位），tab顺序（运行后按TAB键会自动跳焦点），定位器（ctrl+K,输入前面一个字符+空格+定位内容）
2. 主窗口
菜单栏和工具栏他们的action编辑，dock部件（工具箱）
3. 事件系统
事件的处理：先传递到指定窗口部件的（先获得焦点的窗口部件），若该部件忽略该事件就会传到该部件的父部件
重新实现事件处理函数时，一般要调用父类的相应事件处理函数来实现默认操作
Qt中事件对象默认是 accept 的，而作为所有组件的父类QWidget的默认实现则是调用ignore()。
很棒的讲解：https://zhuanlan.zhihu.com/p/50053079
4. QT对象模型和容器类
信号和槽的关联
connect函数参数（发射信号的对象，发射的信号，接受信号的对象，执行的槽（在声明的时候必须使用slots关键字））对于信号和槽必须使用SIGNAL（）和SLOT（）宏；很棒的讲解：https://zhuanlan.zhihu.com/p/86313966
属性系统：
声明属性的必备条件：
    继承于QObject
    使用Q_OBJECT宏
    使用Q_PROPERTY宏

属性声明有2种形式，带MEMBER和不带MEMBER字段；
1. 不带MEMBER字段
形式为：类型+属性名+READ+get函数+WRITE+set函数，其中WRITE+set函数为可选。
2. 带MEMBER字段
形式为：类型+属性名+MEMBER+成员变量名+READ+get函数+WRITE+set函数，其中READ+get函数+WRITE+set函数为可选。
对象树
容器（迭代器）

深复制会复制一个对象，浅复制则是复制一个引用（仅仅是一个指向共享数据库的指针）
=（隐形共享类仅需设置指针和增加引用计数的值）

5. 界面外观
样式表比调色板好，不受其他平台限制，方便实现快速换肤

6. 国际化
使用QT Linguist翻译程序
配置环境变量：
```
export QTDIR=/opt/Qt5.3.2/5.3.2
export PATH=$QTDIR/gcc_64/bin:$PATH
export LD_LIBRARY_PATH=$QTDIR/gcc_64/lib
```
7. 2D绘图


8. 图形视图动画和状态机框架
# 新
1. 规定一些特殊语法表示字符类、数量限定符和位置关系，然后用这些特殊语法和普通字符一起表示一个模式，这就是正则表达式
2.
fork函数的特点概括起来就是“调用一次，返回两次”，在父进程中调用一次，在父进程和子进程中各返回一次。
3. 父进程通过fork可以将打开文件的描述符传递给子进程

子进程结束时，父进程调用wait可以得到子进程的终止信息

几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步

进程之间互发信号，一般使用SIGUSR1和SIGUSR2实现用户自定义功能
